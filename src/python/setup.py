import os
import shutil
import sys
import sysconfig
from pathlib import Path

from setuptools import Distribution, find_namespace_packages, setup

"""
This script expects _pymarian.*.so to be present in $CMAKE_BINARY_DIR

NOTE: Most of (static) metadata is set in pyproject.toml.
#  This setup.py is for specifying dynamic aspect of build. All static metadata is in pyproject.toml
"""

DEF_CMAKE_BINARY_DIR = (Path(__file__).parent / '../../build').resolve()
CMAKE_BINARY_DIR = os.getenv("CMAKE_BINARY_DIR", DEF_CMAKE_BINARY_DIR)
print("\t>>>CMAKE_BINARY_DIR is ", CMAKE_BINARY_DIR)

EXT_SUFFIX = sysconfig.get_config_var('EXT_SUFFIX')  # See also: python -m sysconfig | grep -i EXT_SUFFIX
assert EXT_SUFFIX, "EXT_SUFFIX not found in sysconfig"
NATIVE_EXT_NAME = '_pymarian' + EXT_SUFFIX


def get_version(cuda_version=None) -> str:
    vfile = Path(__file__).parent / '../../VERSION'
    if not vfile.exists() and "CMAKE_SOURCE_DIR" in os.environ:
        # some build tools may copy src/python into a temporary directory, which disconnects it from the source tree
        # using CMAKE_SOURCE_DIR to find the source tree
        vfile = Path(os.environ["CMAKE_SOURCE_DIR"]) / 'VERSION'
    try:
        assert vfile.exists(), f'Version file {vfile.resolve()} does not exist'
        version = vfile.read_text().strip().lstrip("v")  # gets rid of 'v' prefix in v1.17.5 etc.
    except:
        # FIXME: This is a hack. We need to read version from VERSION file
        version = '0.0.0'
        print(
            f'WARNING: Could not read version from {vfile.resolve()}. Setting version to {version}',
            file=sys.stderr,
        )
    version = version if not cuda_version else f"{version}+cu{cuda_version.replace('.', '')}"

    print("\t>>>Marian version is ", version)
    # we need to write version to _version.py file, so that it can be imported from python
    vfile_lines = [
        "# File generated by setuptools; it will be overwritten on every build",
        "# Hence, do not edit or track this file in version control",
        f"__version__ = '{version}'",
        "__cuda_version__ = %s" % ("None" if not cuda_version else f"'{cuda_version}'"),
    ]

    vfile_py = Path(__file__).parent / 'pymarian' / '_version.py'
    vfile_py.write_text("\n".join(vfile_lines))
    return version


def get_native_ext() -> Path:

    native_ext = Path(CMAKE_BINARY_DIR) / 'src' / NATIVE_EXT_NAME
    if not native_ext.exists():
        msg = f"No native extension found at {native_ext}.\n \
        Please run cmake build with -DPYMARIAN=ON or set CMAKE_BINARY_DIR to the existing build dir."
        other_exts = list(Path(CMAKE_BINARY_DIR).glob("src/_pymarian.*." + NATIVE_EXT_NAME.split(".")[-1]))
        if other_exts:
            msg += f"\nOther extension(s) found: {other_exts} but they are not compatible with this platform ({EXT_SUFFIX})."
        raise RuntimeError(msg)
    # Pip does not allow inclusion of files from parent dir our outside of package context (for security reasons).
    # So, we copy the native extension to the package directory
    native_ext_local = Path(__file__).parent / native_ext.name
    print(f"\t>>>Found the fresh native extension at: {native_ext}")
    print(f"\t>>>Making it available under the package scope at: {native_ext_local}")
    shutil.copy(native_ext, native_ext_local)

    # wheel builder adds all *.so files into *.whl making the wheel bloated; so we remove them
    remove_old_files = True
    if remove_old_files:
        # remove incomaptible .so files from prior builds (if any)
        for old_file in Path(__file__).parent.glob("_pymarian.*"):
            if old_file.resolve() == native_ext_local.resolve():
                continue
            print(f"\t>>>INFO:: Removing incompatible extension: {old_file}")
            old_file.unlink()
    return native_ext_local


version = get_version(os.getenv("CUDA_VERSION", default=""))
native_ext = get_native_ext()


# Thanks to https://stackoverflow.com/a/62668026/1506477
class BinaryDistribution(Distribution):
    """Distribution which always forces a binary package with platform name"""

    def has_ext_modules(foo):
        return True


setup(
    version=version,
    package_dir={"pymarian": "pymarian"},
    packages=find_namespace_packages(where=".", exclude=["tests", "binding"]),
    include_package_data=True,
    package_data={"pymarian": [str(native_ext)]},
    distclass=BinaryDistribution,
)
